name: 'Recurring Backlog Item Creator'
description: 'Automatically create and manage GitHub issues in your project backlog based on a YAML configuration file'
branding:
  icon: 'repeat'
  color: 'blue'

inputs:
  token:
    description: 'GitHub token with appropriate permissions'
    required: true
  config:
    description: 'Path to the YAML configuration file'
    required: true

runs:
  using: 'composite'
  steps:
    - name: Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.25'
        cache-dependency-path: './gh-issue-config-filter/go.sum'

    - name: Build filter tool
      shell: bash
      working-directory: ./gh-issue-config-filter
      run: make build

    - name: Filter issues
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.token }}
      run: |
        MONTH=$(date +%m | sed 's/^0//')
        ./gh-issue-config-filter/bin/gh-issue-config-filter --month $MONTH --config "${{ inputs.config }}" --debug > issues_with_debug.json 2>&1 || {
          echo "Filter tool failed. Full output:"
          cat issues_with_debug.json
          exit 1
        }
        # Extract JSON from output (skip debug logs that start with [DEBUG] or timestamps)
        grep -v "^\[DEBUG\]" issues_with_debug.json | grep -v "^2025/" > issues.json || {
          echo "Failed to extract JSON. Full output:"
          cat issues_with_debug.json
          exit 1
        }
        echo "Filtered issues JSON:"
        cat issues.json

    - name: Create issues and register to projects
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.token }}
      run: |
        cat issues.json | jq -c '.[]' | while read issue; do
          TEMPLATE=$(echo $issue | jq -r '.template_file')
          TITLE=$(echo $issue | jq -r '.title')
          PROJECT_ID=$(echo $issue | jq -r '.project_id')
          TARGET_REPO=$(echo $issue | jq -r '.target_repo')
          
          echo "Creating issue: $TITLE"
          
          # Read template body
          TEMPLATE_BODY=$(cat "$TEMPLATE")
          
          # Create issue using GitHub API
          ISSUE_RESPONSE=$(gh api repos/$TARGET_REPO/issues \
            -X POST \
            -f title="$TITLE" \
            -f body="$TEMPLATE_BODY" \
            --jq '.html_url')
          
          echo "Created: $ISSUE_RESPONSE"
          ISSUE_URL="$ISSUE_RESPONSE"
          
          sleep 2  # Rate limit protection

          # Extract issue number from URL (format: https://github.com/owner/repo/issues/123)
          ISSUE_NUMBER=$(echo "$ISSUE_URL" | sed 's/.*\/issues\/\([0-9]*\).*/\1/')
          REPO_OWNER=$(echo "$TARGET_REPO" | cut -d'/' -f1)
          REPO_NAME=$(echo "$TARGET_REPO" | cut -d'/' -f2)
          
          # Add to project using GraphQL API
          ITEM_ID=$(gh api graphql -f query='
            mutation($projectId: ID!, $contentId: ID!) {
              addProjectV2ItemById(input: {projectId: $projectId, contentId: $contentId}) {
                item {
                  id
                }
              }
            }
          ' -f projectId="$PROJECT_ID" -f contentId="$(gh api repos/$TARGET_REPO/issues/$ISSUE_NUMBER --jq '.node_id')" --jq '.data.addProjectV2ItemById.item.id')
          
          echo "Added to project. Item ID: $ITEM_ID"
          
          # Set fields using GraphQL API
          # Process each element in field_updates array
          echo "$issue" | jq -c '.field_updates[]?' | while read field_update; do
            FIELD_ID=$(echo "$field_update" | jq -r '.field_id')
            FIELD_TYPE=$(echo "$field_update" | jq -r '.field_type')
            VALUE=$(echo "$field_update" | jq -r '.value // empty')
            OPTION_ID=$(echo "$field_update" | jq -r '.option_id // empty')
            
            case "$FIELD_TYPE" in
              "TEXT"|"NUMBER")
                if [ -n "$VALUE" ]; then
                  gh api graphql -f query='
                    mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $value: String!) {
                      updateProjectV2ItemFieldValue(input: {
                        projectId: $projectId
                        itemId: $itemId
                        fieldId: $fieldId
                        value: { text: $value }
                      }) {
                        projectV2Item {
                          id
                        }
                      }
                    }
                  ' -f projectId="$PROJECT_ID" -f itemId="$ITEM_ID" -f fieldId="$FIELD_ID" -f value="$VALUE" > /dev/null
                  echo "Set field $FIELD_ID to $VALUE"
                fi
                ;;
              "SINGLE_SELECT")
                if [ -n "$OPTION_ID" ]; then
                  gh api graphql -f query='
                    mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                      updateProjectV2ItemFieldValue(input: {
                        projectId: $projectId
                        itemId: $itemId
                        fieldId: $fieldId
                        value: { singleSelectOptionId: $optionId }
                      }) {
                        projectV2Item {
                          id
                        }
                      }
                    }
                  ' -f projectId="$PROJECT_ID" -f itemId="$ITEM_ID" -f fieldId="$FIELD_ID" -f optionId="$OPTION_ID" > /dev/null
                  echo "Set field $FIELD_ID to option $OPTION_ID"
                fi
                ;;
            esac
          done
          
          sleep 2  # Rate limit protection
        done

